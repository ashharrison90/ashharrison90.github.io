(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[716],{7886:function(e,t,r){(window.__NEXT_P=window.__NEXT_P||[]).push(["/posts/betterer",function(){return r(9691)}])},9691:function(e,t,r){"use strict";r.r(t),r.d(t,{default:function(){return h},metadata:function(){return o}});var n=r(5893),s=r(1151),i=r(1080);let o={title:"Betterer",excerpt:"My new favourite tool when working in a large codebase.",coverImage:"/assets/blog/betterer/strict-metrics.webp",date:"2022-04-24T17:40:07.322Z",tags:["tooling","ci"]},a=e=>{let{children:t}=e;return(0,n.jsx)(i.Z,{metadata:o,children:t})};function c(e){let t={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h2,{children:"Improving incrementally"}),"\n",(0,n.jsx)(t.p,{children:"Part of the pain of working on any collaborative software project comes when trying to introduce big improvements to the codebase."}),"\n",(0,n.jsxs)(t.p,{children:["Imagine you have a large project written in TypeScript. You want to enable ",(0,n.jsx)(t.a,{href:"https://www.typescriptlang.org/tsconfig#strict",children:"strict type checking"}),", but you're a long way off fixing all the errors. How do you move forward?"]}),"\n",(0,n.jsx)(t.p,{children:"That was the situation at Grafana around 2 years ago. One option is to introduce these fixes gradually and hope you can outpace the rate at which new errors are introduced."}),"\n",(0,n.jsxs)("figure",{children:[(0,n.jsx)("video",{autoPlay:!0,loop:!0,muted:!0,type:"video/mp4",src:"/assets/blog/betterer/escalator.mp4",alt:"Making large changes incrementally can feel like running the wrong way up an escalator."}),(0,n.jsx)("figcaption",{children:(0,n.jsx)(t.p,{children:"Making large changes incrementally can feel like running the wrong way up an\nescalator."})})]}),"\n",(0,n.jsxs)(t.p,{children:["This feels a bit like running up an escalator. Instead, we ",(0,n.jsx)(t.a,{href:"https://github.com/grafana/grafana/blob/a7afab4b8aa92c32a05057047d42bcb6a91114aa/scripts/ci-check-strict.sh",children:"introduced a shell script"})," that would run in the CI:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-bash",children:'#!/bin/bash\nset -e\n\necho -e "Collecting code stats (typescript errors & more)"\n\nERROR_COUNT_LIMIT=579\nERROR_COUNT="$(./node_modules/.bin/tsc --project tsconfig.json --noEmit --strict true | grep -oP \'Found \\K(\\d+)\')"\n\nif [ "$ERROR_COUNT" -gt $ERROR_COUNT_LIMIT ]; then\n  echo -e "Typescript strict errors $ERROR_COUNT exceeded $ERROR_COUNT_LIMIT so failing build"\n	exit 1\nfi\n'})}),"\n",(0,n.jsx)(t.p,{children:"There's nothing special about this. It's just a bash script that runs the typescript compiler and checks the number of strict errors against our predefined threshold, similar to a snapshot test. As errors are fixed we would update the threshold to ensure that more errors aren't introduced."}),"\n",(0,n.jsx)(t.p,{children:"The main problem was that it relied on developers remembering to update the threshold whenever they fixed errors."}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"But"})," it did work. Over the course of 18 months we went from ~800 strict typescript errors to 0."]}),"\n",(0,n.jsxs)("figure",{children:[(0,n.jsx)("img",{src:"/assets/blog/betterer/strict-metrics.webp",alt:"TypeScript strict errors over time for the Grafana project."}),(0,n.jsx)("figcaption",{children:(0,n.jsx)(t.p,{children:"TypeScript strict errors over time for the Grafana project."})})]}),"\n",(0,n.jsx)(t.p,{children:"You can see from the graph that there are several places where the number of errors went up. This is exactly the sort of thing the script was supposed to avoid. Is there a better(er) way?"}),"\n",(0,n.jsx)(t.h2,{children:"The Betterer way"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.a,{href:"https://phenomnomnominal.github.io/betterer/",children:"Betterer"})," takes this concept of snapshot testing to the next level. At it's core, it does exactly the same thing as we discussed above. ",(0,n.jsx)(t.strong,{children:"But it does all this automatically for you"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"Setup is a 1-liner:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-bash",children:"npx @betterer/cli init\n"})}),"\n",(0,n.jsxs)(t.p,{children:["This will install the relevant dependencies and create a ",(0,n.jsx)(t.code,{children:".betterer.ts"})," file in the project root. This ",(0,n.jsx)(t.code,{children:".betterer.ts"})," file is where you define the criteria you want to test against to improve."]}),"\n",(0,n.jsxs)(t.p,{children:["With React 18 now being released and Enzyme ",(0,n.jsx)(t.a,{href:"https://github.com/enzymejs/enzyme/issues/2429",children:"still not officially supporting React 17"}),", a good example might be ",(0,n.jsx)(t.a,{href:"https://github.com/grafana/grafana/pull/45055",children:"tracking the conversion of your unit tests from Enzyme to React Testing Library"}),". Writing a test for that couldn't be simpler:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-typescript",children:"import { regexp } from '@betterer/regexp'\n\nexport default {\n  'no enzyme tests': () => regexp(/from 'enzyme'/g).include('**/*.test.*'),\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["This uses the ",(0,n.jsx)(t.code,{children:"@betterer/regexp"})," package to check if how many test files contain the import string ",(0,n.jsx)(t.code,{children:"from 'enzyme'"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["Betterer can then be run either as a precommit hook (",(0,n.jsx)(t.code,{children:"betterer precommit"}),") in combination with ",(0,n.jsx)(t.code,{children:"husky"}),"/",(0,n.jsx)(t.code,{children:"lint-staged"})," or in the CI (",(0,n.jsx)(t.code,{children:"betterer ci"}),") or both. Running it generates a ",(0,n.jsx)(t.code,{children:".betterer.results"})," file in the project root. This is effectively a snapshot of the current state of the codebase."]}),"\n",(0,n.jsx)(t.p,{children:"Each time Betterer runs it will compare against the previous snapshot. If a test criteria has got worse, Betterer will fail. If it gets better, Betterer will update the snapshot and tighten the restriction further. Importantly, as there's nothing that an individual developer needs to remember to do, there's no sign of any increases when we look at the graph:"}),"\n",(0,n.jsxs)("figure",{children:[(0,n.jsx)("img",{src:"/assets/blog/betterer/enzyme-metrics.webp",alt:"Number of Enzyme tests over time for the Grafana project."}),(0,n.jsx)("figcaption",{children:(0,n.jsx)(t.p,{children:"Number of Enzyme tests over time for the Grafana project."})})]}),"\n",(0,n.jsxs)(t.p,{children:["There's also support for caching to speed up running Betterer, making ",(0,n.jsx)(t.a,{href:"https://github.com/grafana/grafana/pull/45901",children:"complicated tests more viable"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["That's it! I thoroughly recommend checking the tool out and giving it a try. Huge shout out to ",(0,n.jsx)(t.a,{href:"https://twitter.com/phenomnominal",children:"@phenomnomnominal"})," for developing the package and being so responsive on ",(0,n.jsx)(t.a,{href:"https://discord.gg/YNgtXt6QVX",children:"discord"}),"."]})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return(0,n.jsx)(a,{...e,children:(0,n.jsx)(c,{...e})})}},1151:function(e,t,r){"use strict";r.d(t,{a:function(){return i}});var n=r(7294);let s=n.createContext({});function i(e){let t=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}}},function(e){e.O(0,[325,514,381,80,774,888,179],function(){return e(e.s=7886)}),_N_E=e.O()}]);